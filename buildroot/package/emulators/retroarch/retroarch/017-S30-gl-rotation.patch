diff --git a/gfx/common/gl_common.h b/gfx/common/gl_common.h
index 69c9eb2491..2d69fc032b 100644
--- a/gfx/common/gl_common.h
+++ b/gfx/common/gl_common.h
@@ -218,7 +218,7 @@ struct gl
 
    struct scaler_ctx pbo_readback_scaler;
    struct video_viewport vp;                          /* int alignment */
-   math_matrix_4x4 mvp, mvp_no_rot;
+   math_matrix_4x4 mvp, mvp_no_rot, mvp_screen_rot;
    struct video_coords coords;                        /* ptr alignment */
    struct scaler_ctx scaler;
    video_info_t video_info;
diff --git a/gfx/drivers/gl.c b/gfx/drivers/gl.c
index 4688e203b7..7eba7c02ab 100644
--- a/gfx/drivers/gl.c
+++ b/gfx/drivers/gl.c
@@ -370,20 +370,23 @@ static bool gl2_recreate_fbo(
 static void gl2_set_projection(gl_t *gl,
       struct video_ortho *ortho, bool allow_rotate)
 {
-   math_matrix_4x4 rot;
-
    /* Calculate projection. */
    matrix_4x4_ortho(gl->mvp_no_rot, ortho->left, ortho->right,
          ortho->bottom, ortho->top, ortho->znear, ortho->zfar);
 
+   math_matrix_4x4 scrn_rot;
+   matrix_4x4_rotate_z(scrn_rot, M_PI * 90 / 180.0f);
+   matrix_4x4_multiply(gl->mvp_screen_rot, scrn_rot, gl->mvp_no_rot);
+
    if (!allow_rotate)
    {
-      gl->mvp = gl->mvp_no_rot;
+      gl->mvp = gl->mvp_screen_rot;
       return;
    }
 
+   math_matrix_4x4 rot;
    matrix_4x4_rotate_z(rot, M_PI * gl->rotation / 180.0f);
-   matrix_4x4_multiply(gl->mvp, rot, gl->mvp_no_rot);
+   matrix_4x4_multiply(gl->mvp, rot, gl->mvp_screen_rot);
 }
 
 static void gl2_set_viewport(gl_t *gl,
@@ -467,7 +470,8 @@ static void gl2_set_viewport(gl_t *gl,
       gl->vp.y *= 2;
 #endif
 
-   glViewport(gl->vp.x, gl->vp.y, gl->vp.width, gl->vp.height);
+   //glViewport(gl->vp.x, gl->vp.y, gl->vp.width, gl->vp.height);
+   glViewport(gl->vp.y, gl->vp.x, gl->vp.height, gl->vp.width);
    gl2_set_projection(gl, &default_ortho, allow_rotate);
 
    /* Set last backbuffer viewport. */
@@ -1881,7 +1885,8 @@ static void gl2_render_overlay(gl_t *gl)
    glEnable(GL_BLEND);
 
    if (gl->overlay_full_screen)
-      glViewport(0, 0, width, height);
+      glViewport(0, 0, height, height);
+      //glViewport(0, 0, width, height);
 
    /* Ensure that we reset the attrib array. */
    gl->shader->use(gl, gl->shader_data,
@@ -1893,7 +1898,8 @@ static void gl2_render_overlay(gl_t *gl)
    gl->coords.vertices  = 4 * gl->overlays;
 
    gl->shader->set_coords(gl->shader_data, &gl->coords);
-   gl->shader->set_mvp(gl->shader_data, &gl->mvp_no_rot);
+   gl->shader->set_mvp(gl->shader_data, &gl->mvp_screen_rot);
+   //gl->shader->set_mvp(gl->shader_data, &gl->mvp_no_rot);
 
    for (i = 0; i < gl->overlays; i++)
    {
@@ -1907,7 +1913,8 @@ static void gl2_render_overlay(gl_t *gl)
    gl->coords.color     = gl->white_color_ptr;
    gl->coords.vertices  = 4;
    if (gl->overlay_full_screen)
-      glViewport(gl->vp.x, gl->vp.y, gl->vp.width, gl->vp.height);
+      glViewport(gl->vp.y, gl->vp.x, gl->vp.height, gl->vp.width);
+      //glViewport(gl->vp.x, gl->vp.y, gl->vp.width, gl->vp.height);
 }
 #endif
 
@@ -2364,7 +2371,8 @@ static void gl2_render_osd_background(gl_t *gl, const char *msg)
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glBlendEquation(GL_FUNC_ADD);
 
-   gl->shader->set_mvp(gl->shader_data, &gl->mvp_no_rot);
+   gl->shader->set_mvp(gl->shader_data, &gl->mvp_screen_rot);
+   //gl->shader->set_mvp(gl->shader_data, &gl->mvp_no_rot);
 
    uniform_param.type              = UNIFORM_4F;
    uniform_param.enabled           = true;
@@ -2458,7 +2466,8 @@ static INLINE void gl2_draw_texture(gl_t *gl)
    gl->coords.vertices    = 4;
 
    gl->shader->set_coords(gl->shader_data, &gl->coords);
-   gl->shader->set_mvp(gl->shader_data, &gl->mvp_no_rot);
+   gl->shader->set_mvp(gl->shader_data, &gl->mvp_screen_rot);
+   //gl->shader->set_mvp(gl->shader_data, &gl->mvp_no_rot);
 
    glEnable(GL_BLEND);
 
@@ -3147,6 +3156,7 @@ static bool gl2_frame(void *data, const void *frame,
       glBindVertexArray(0);
 #endif
    gl2_context_bind_hw_render(gl, true);
+
    return true;
 }
 
